import requests
import moviepy.editor as mp
import speech_recognition as sr
import requests
import time
from flashcards_from_pdf import flashcard_creator as fc

API_KEY_ASSEMBLYAI = ''

upload_endpoint = 'https://api.assemblyai.com/v2/upload'
transcript_endpoint = 'https://api.assemblyai.com/v2/transcript'

headers_auth_only = {'authorization': API_KEY_ASSEMBLYAI}

headers = {
    "authorization": API_KEY_ASSEMBLYAI,
    "content-type": "application/json"
}


def upload(audioFileName):
    def read_file(audioFileName):#reads the file
        with open(audioFileName, 'rb') as f:#open the file and read it as binary
            while True:#deh infinite loop
                data = f.read()#This line reads the file data in chunks.
                if not data:#lw mafe4 data break
                    break
                yield data#this line yields the current data chunk, allowing the function to be used as a generator.

    upload_response = requests.post(upload_endpoint, headers=headers_auth_only, data=read_file(audioFileName))#This line sends a POST request to the AssemblyAI upload endpoint, passing the headers and data 
    #(generated by the read_file function) as parameters. The response is stored in the upload_response variable.

    return upload_response.json()['upload_url']#This line extracts the 'upload_url' property from the JSON response and returns it as the result of the upload function.
    

def transcribe(audio_url):
    transcript_request = {#This line creates a dictionary called transcript_request with a single key-value pair.
                          #The key is 'audio_url', and the value is the audio_url parameter passed to the function.
        'audio_url': audio_url
    }

    transcript_response = requests.post(transcript_endpoint, json=transcript_request, headers=headers)#This line sends a POST request to the AssemblyAI transcript endpoint
    # (transcript_endpoint) with the transcript_request dictionary as the request body (serialized to JSON using the json parameter)
    # and the headers dictionary as the request headers. The response is stored in the transcript_response variable.
    return transcript_response.json()['id']
    #extracts the 'id' property from the JSON response (using the json method of the response object) and returns it as the result of the transcribe function.


def poll(transcript_id):
    polling_endpoint = transcript_endpoint + '/' + transcript_id#combines the transcript_endpoint (the URL of the AssemblyAI transcript endpoint) with the transcript_id to form the specific URL for
                                                                # polling the status of a transcript task. The transcript_id is appended to the transcript_endpoint using a forward slash '/'.
    polling_response = requests.get(polling_endpoint, headers=headers)
    #This line sends a GET request to the polling_endpoint URL to check the status of the transcript task. It uses the requests.get method,
    # passing the polling_endpoint URL and the headers dictionary as parameters. The response is stored in the polling_response variable.
    return polling_response.json()
   #returns the JSON content of the response. It uses the json method of the response object to parse the response content and convert it into a Python dictionary.

def get_transcription_result_url(url):
    transcribe_id = transcribe(url)#calls the transcribe function (previously defined) with the url parameter and assigns the returned transcribe_id
    # (the ID of the transcription task) to the transcribe_id variable.
    while True:
        data = poll(transcribe_id)#This line calls the poll function (previously defined) with the transcribe_id parameter and assigns the returned status data to the data variable.
        if data['status'] == 'completed':
            return data, None# returns the data dictionary and None if the 'status' is 'completed'. This indicates that the transcription task has been completed successfully.
        elif data['status'] == 'error':
            return data, data['error']#This line returns the data dictionary and the value of the 'error' key in the data dictionary if the 'status' is 'error'. This indicates that an error occurred during the transcription task.

        # print("waiting for 30 seconds")
        # time.sleep(30)#This line pauses the execution of the code for 30 seconds.


def save_transcript(url, title):
    data, error = get_transcription_result_url(url)#calls the get_transcription_result_url function with the url parameter and assigns the returned data and error values to the respective variables.

    if data:
        audioFileName = 'assets/output files/extracted transcripts/'+title + '.txt'
        with open(audioFileName, 'w') as f:
            f.write(data['text'])
        print('Transcript saved')
    elif error:
        print("Error!!!", error)
def main():
    videoFilePath = 'assets/input files/videos/'
    videoFileName = 'Speech to Text using Python - Fast and Accurate-(144p)'
    videoFileExtension = '.mp4'

    video = mp.VideoFileClip(videoFilePath+videoFileName+videoFileExtension)

    audioFilePath = 'assets/output files/extracted audio/'
    audioFileName = videoFileName+"_extracted_audio"
    audioFileExtension = '.wav'
    audioFileForTranscription = audioFilePath+audioFileName+audioFileExtension

    audio = video.audio
    audio.write_audiofile(audioFileForTranscription)


    audio_url = upload(audioFileForTranscription)
    save_transcript(audio_url, videoFileName+'_transcribed_text')
if __name__ == "__main__":
    main()
